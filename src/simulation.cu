//
// Created by goader on 11/5/23.
//

#include "simulation.cuh"

// todo create functors for our custom random engine
// todo introduce a constant first inactive point
Simulation::Simulation(const SimulationConfig& config) : config(config) {
    rng = RandomEngine(config);

    particlesX = thrust::device_vector<float>(config.numParticles);
    particlesY = thrust::device_vector<float>(config.numParticles);
    particlesActive = thrust::device_vector<bool>(config.numParticles);

    thrust::fill(particlesActive.begin(), particlesActive.end(), true);

    // todo we can swap this out for a custom functor
    for (int i = 0; i < config.numParticles; i++) {
        particlesX[i] = rng.generateParticleX();
        particlesY[i] = rng.generateParticleY();
    }
}

// todo generated by copilot, to review!
void Simulation::step() {
    // todo we can swap this out for a custom functor
    for (int i = 0; i < config.numParticles; i++) {
        if (!particlesActive[i]) {
            continue;
        }

        float angle = rng.generateAngle();
        float newX = particlesX[i] + config.moveRadius * cos(angle);
        float newY = particlesY[i] + config.moveRadius * sin(angle);

        if (newX < 0 || newX >= config.width || newY < 0 || newY >= config.height) {
            // fixme wrong (clip to edge)
            if (config.respawnParticles) {
                particlesX[i] = rng.generateParticleX();
                particlesY[i] = rng.generateParticleY();
            } else {
                particlesActive[i] = false;
            }
        } else {
            particlesX[i] = newX;
            particlesY[i] = newY;
        }
    }

    // todo we can swap this out for a custom functor
    for (int i = 0; i < config.numParticles; i++) {
        if (!particlesActive[i]) {
            continue;
        }

        for (int j = 0; j < config.numParticles; j++) {
            if (i == j || particlesActive[j]) {
                continue;
            }

            float dx = particlesX[i] - particlesX[j];
            float dy = particlesY[i] - particlesY[j];
            float distance = sqrt(dx * dx + dy * dy);

            if (distance < config.particleRadius) {
                particlesActive[i] = false;
                particlesActive[j] = false;
            }
        }
    }
}

bool Simulation::isFinished() const {
    bool anyActive = thrust::reduce(
        particlesActive.begin(),
        particlesActive.end(),
        false,
        thrust::logical_or<bool>()
    );
    return !anyActive;
}

std::vector<int> Simulation::getParticlesX() const {
    thrust::host_vector<int> hostParticlesX = particlesX;
    return {hostParticlesX.begin(), hostParticlesX.end()};
}

std::vector<int> Simulation::getParticlesY() const {
    thrust::host_vector<int> hostParticlesY = particlesY;
    return {hostParticlesY.begin(), hostParticlesY.end()};
}
